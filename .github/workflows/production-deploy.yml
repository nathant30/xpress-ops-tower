# Production Deployment Workflow for Xpress Ops Tower
# Critical emergency system deployment with comprehensive testing and monitoring

name: 🚀 Production Deployment

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      emergency_deploy:
        description: 'Emergency deployment (skip non-critical tests)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '18.x'
  POSTGRES_VERSION: '15'
  REDIS_VERSION: '7'

jobs:
  # Critical system validation
  security-scan:
    name: 🔒 Security Scan
    runs-on: ubuntu-latest
    if: github.event.inputs.emergency_deploy != 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run dependency security audit
      run: |
        npm audit --audit-level=moderate
        if [ $? -ne 0 ]; then
          echo "🚨 Security vulnerabilities found in dependencies"
          exit 1
        fi
    
    - name: Run custom security scanner
      run: node security/security-scanner.js http://localhost:3000
      continue-on-error: false
    
    - name: Upload security scan results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: security-scan-results
        path: security/reports/
        retention-days: 30

  # Database and infrastructure tests
  database-tests:
    name: 🗄️ Database Performance Tests
    runs-on: ubuntu-latest
    if: github.event.inputs.emergency_deploy != 'true'
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_USER: test_user
          POSTGRES_DB: xpress_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Setup test database
      run: |
        PGPASSWORD=test_password psql -h localhost -U test_user -d xpress_test -f database/migrations/001_initial_setup.sql
        PGPASSWORD=test_password psql -h localhost -U test_user -d xpress_test -f database/migrations/002_partitioning_setup.sql
        PGPASSWORD=test_password psql -h localhost -U test_user -d xpress_test -f database/migrations/003_performance_indexes.sql
        PGPASSWORD=test_password psql -h localhost -U test_user -d xpress_test -f database/migrations/004_sos_emergency_system.sql
    
    - name: Run database performance tests
      env:
        TEST_DATABASE_URL: postgres://test_user:test_password@localhost:5432/xpress_test
        TEST_REDIS_URL: redis://localhost:6379
      run: |
        npm run test:database-performance
        if [ $? -ne 0 ]; then
          echo "🚨 Database performance tests failed"
          exit 1
        fi

  # Unit and integration tests
  test-suite:
    name: 🧪 Test Suite
    runs-on: ubuntu-latest
    strategy:
      matrix:
        test-group: [unit, integration, emergency]
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_USER: test_user
          POSTGRES_DB: xpress_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Setup test environment
      env:
        TEST_DATABASE_URL: postgres://test_user:test_password@localhost:5432/xpress_test
        TEST_REDIS_URL: redis://localhost:6379
      run: |
        # Setup database
        PGPASSWORD=test_password psql -h localhost -U test_user -d xpress_test -f database/migrations/001_initial_setup.sql
        PGPASSWORD=test_password psql -h localhost -U test_user -d xpress_test -f database/migrations/004_sos_emergency_system.sql
    
    - name: Run unit tests
      if: matrix.test-group == 'unit'
      run: |
        npm run test:unit
        echo "📊 Unit test coverage:"
        npm run test:coverage
    
    - name: Run integration tests
      if: matrix.test-group == 'integration'
      env:
        TEST_DATABASE_URL: postgres://test_user:test_password@localhost:5432/xpress_test
        TEST_REDIS_URL: redis://localhost:6379
      run: npm run test:integration
    
    - name: Run emergency system tests
      if: matrix.test-group == 'emergency'
      env:
        TEST_DATABASE_URL: postgres://test_user:test_password@localhost:5432/xpress_test
        TEST_REDIS_URL: redis://localhost:6379
      run: |
        echo "🚨 Testing critical emergency system (<5 second requirement)"
        npm run test:emergency
        if [ $? -ne 0 ]; then
          echo "🚨 CRITICAL: Emergency system tests failed - deployment blocked"
          exit 1
        fi
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.test-group }}
        path: |
          test-results/
          coverage/
        retention-days: 30

  # End-to-end tests
  e2e-tests:
    name: 🎭 End-to-End Tests
    runs-on: ubuntu-latest
    if: github.event.inputs.emergency_deploy != 'true'
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_USER: test_user
          POSTGRES_DB: xpress_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Setup test database
      run: |
        PGPASSWORD=test_password psql -h localhost -U test_user -d xpress_test -f database/migrations/001_initial_setup.sql
        PGPASSWORD=test_password psql -h localhost -U test_user -d xpress_test -f database/migrations/004_sos_emergency_system.sql
        PGPASSWORD=test_password psql -h localhost -U test_user -d xpress_test -f database/seeds/001_sample_data.sql
    
    - name: Build application
      run: npm run build
    
    - name: Start application
      env:
        DATABASE_URL: postgres://test_user:test_password@localhost:5432/xpress_test
        REDIS_URL: redis://localhost:6379
        NODE_ENV: test
      run: |
        npm start &
        APP_PID=$!
        echo "APP_PID=$APP_PID" >> $GITHUB_ENV
        
        # Wait for application to be ready
        for i in {1..60}; do
          if curl -f http://localhost:3000/api/health > /dev/null 2>&1; then
            echo "Application is ready"
            break
          fi
          echo "Waiting for application... ($i/60)"
          sleep 2
        done
    
    - name: Install Playwright
      run: npx playwright install chromium
    
    - name: Run emergency workflow E2E tests
      run: |
        echo "🚨 Testing critical emergency workflows end-to-end"
        npx playwright test __tests__/e2e/emergency-workflows.spec.ts
        if [ $? -ne 0 ]; then
          echo "🚨 CRITICAL: Emergency workflow E2E tests failed"
          exit 1
        fi
    
    - name: Stop application
      if: always()
      run: |
        if [ -n "$APP_PID" ]; then
          kill $APP_PID
        fi
    
    - name: Upload E2E test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: e2e-test-results
        path: |
          test-results/
          playwright-report/
        retention-days: 30

  # Load testing (conditional)
  load-tests:
    name: ⚡ Load Testing
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: [test-suite]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install k6
      run: |
        sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6
    
    - name: Run load tests (light)
      run: |
        echo "⚡ Running load tests for emergency system"
        cd __tests__/load
        k6 run --duration 2m --vus 100 scenarios/emergencyLoadTest.js
        if [ $? -ne 0 ]; then
          echo "⚠️  Load tests failed - review performance"
          exit 1
        fi

  # Build and prepare deployment
  build:
    name: 🏗️ Build Application
    runs-on: ubuntu-latest
    needs: [security-scan, test-suite]
    if: always() && (needs.test-suite.result == 'success')
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      image-tag: ${{ steps.version.outputs.image-tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run type checking
      run: npm run type-check
    
    - name: Run linting
      run: npm run lint
    
    - name: Build application
      run: |
        npm run build
        echo "📦 Application built successfully"
    
    - name: Generate version
      id: version
      run: |
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
        else
          VERSION="v$(date +%Y%m%d)-${GITHUB_SHA::8}"
        fi
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "image-tag=xpress-ops-tower:$VERSION" >> $GITHUB_OUTPUT
        echo "Generated version: $VERSION"
    
    - name: Create deployment package
      run: |
        mkdir -p deployment-package
        
        # Copy essential files
        cp -r .next deployment-package/
        cp -r public deployment-package/
        cp -r database deployment-package/
        cp -r monitoring deployment-package/
        cp package.json deployment-package/
        cp package-lock.json deployment-package/
        cp next.config.js deployment-package/
        
        # Copy deployment scripts
        cp -r scripts deployment-package/
        
        # Create deployment info
        echo "{
          \"version\": \"${{ steps.version.outputs.version }}\",
          \"build_time\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
          \"commit_sha\": \"$GITHUB_SHA\",
          \"branch\": \"${GITHUB_REF#refs/heads/}\",
          \"emergency_ready\": true
        }" > deployment-package/deployment-info.json
        
        # Create tarball
        tar -czf xpress-ops-tower-${{ steps.version.outputs.version }}.tar.gz -C deployment-package .
    
    - name: Upload deployment package
      uses: actions/upload-artifact@v4
      with:
        name: deployment-package-${{ steps.version.outputs.version }}
        path: xpress-ops-tower-${{ steps.version.outputs.version }}.tar.gz
        retention-days: 90

  # Staging deployment
  deploy-staging:
    name: 🎯 Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build, database-tests]
    if: |
      always() && 
      (needs.build.result == 'success') && 
      (github.event.inputs.environment == 'staging' || 
       (github.event_name == 'push' && github.ref == 'refs/heads/main'))
    
    environment:
      name: staging
      url: https://staging.xpress-ops-tower.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download deployment package
      uses: actions/download-artifact@v4
      with:
        name: deployment-package-${{ needs.build.outputs.version }}
    
    - name: Deploy to staging
      env:
        STAGING_HOST: ${{ secrets.STAGING_HOST }}
        STAGING_USER: ${{ secrets.STAGING_USER }}
        STAGING_SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}
        DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
        REDIS_URL: ${{ secrets.STAGING_REDIS_URL }}
      run: |
        echo "🚀 Deploying to staging environment"
        
        # Setup SSH
        mkdir -p ~/.ssh
        echo "$STAGING_SSH_KEY" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H $STAGING_HOST >> ~/.ssh/known_hosts
        
        # Extract deployment package
        tar -xzf xpress-ops-tower-${{ needs.build.outputs.version }}.tar.gz
        
        # Upload to staging
        scp -r ./* $STAGING_USER@$STAGING_HOST:/opt/xpress-ops-tower/
        
        # Deploy on staging server
        ssh $STAGING_USER@$STAGING_HOST << 'EOF'
          cd /opt/xpress-ops-tower
          
          # Install dependencies
          npm ci --production
          
          # Run database migrations
          npm run db:migrate
          
          # Restart services
          sudo systemctl restart xpress-ops-tower
          sudo systemctl restart nginx
          
          # Wait for service to be ready
          sleep 30
          
          # Health check
          if curl -f http://localhost:3000/api/health > /dev/null 2>&1; then
            echo "✅ Staging deployment successful"
          else
            echo "❌ Staging deployment failed - service not healthy"
            exit 1
          fi
        EOF
    
    - name: Run staging smoke tests
      run: |
        echo "🧪 Running staging smoke tests"
        
        # Wait for deployment to stabilize
        sleep 30
        
        # Critical system checks
        curl -f https://staging.xpress-ops-tower.com/api/health || exit 1
        curl -f https://staging.xpress-ops-tower.com/api/integrations/health || exit 1
        
        echo "✅ Staging smoke tests passed"
    
    - name: Notify staging deployment
      if: always()
      run: |
        STATUS="${{ job.status }}"
        if [ "$STATUS" = "success" ]; then
          echo "✅ Staging deployment successful"
        else
          echo "❌ Staging deployment failed"
        fi

  # Production deployment (manual approval required)
  deploy-production:
    name: 🚀 Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, deploy-staging, e2e-tests, load-tests]
    if: |
      always() && 
      (needs.build.result == 'success') && 
      (needs.deploy-staging.result == 'success') &&
      (github.event.inputs.environment == 'production' || 
       (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')))
    
    environment:
      name: production
      url: https://xpress-ops-tower.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download deployment package
      uses: actions/download-artifact@v4
      with:
        name: deployment-package-${{ needs.build.outputs.version }}
    
    - name: Pre-deployment checks
      env:
        PRODUCTION_DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
        PRODUCTION_REDIS_URL: ${{ secrets.PRODUCTION_REDIS_URL }}
      run: |
        echo "🔍 Running pre-deployment checks"
        
        # Verify critical dependencies are available
        curl -f https://api.twilio.com/2010-04-01/ || echo "⚠️  Twilio API check failed"
        curl -f https://api.sendgrid.com/v3/ || echo "⚠️  SendGrid API check failed"
        
        # Database connection check would go here
        echo "✅ Pre-deployment checks completed"
    
    - name: Deploy to production (Blue-Green)
      env:
        PRODUCTION_HOST_BLUE: ${{ secrets.PRODUCTION_HOST_BLUE }}
        PRODUCTION_HOST_GREEN: ${{ secrets.PRODUCTION_HOST_GREEN }}
        PRODUCTION_USER: ${{ secrets.PRODUCTION_USER }}
        PRODUCTION_SSH_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
        DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
        REDIS_URL: ${{ secrets.PRODUCTION_REDIS_URL }}
        LOAD_BALANCER_HOST: ${{ secrets.LOAD_BALANCER_HOST }}
      run: |
        echo "🚀 Deploying to production (Blue-Green deployment)"
        
        # Setup SSH
        mkdir -p ~/.ssh
        echo "$PRODUCTION_SSH_KEY" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H $PRODUCTION_HOST_BLUE >> ~/.ssh/known_hosts
        ssh-keyscan -H $PRODUCTION_HOST_GREEN >> ~/.ssh/known_hosts
        ssh-keyscan -H $LOAD_BALANCER_HOST >> ~/.ssh/known_hosts
        
        # Extract deployment package
        tar -xzf xpress-ops-tower-${{ needs.build.outputs.version }}.tar.gz
        
        # Determine inactive environment (Blue-Green)
        ACTIVE_ENV=$(ssh $PRODUCTION_USER@$LOAD_BALANCER_HOST "cat /opt/load-balancer/active-env.txt || echo 'green'")
        if [ "$ACTIVE_ENV" = "blue" ]; then
          DEPLOY_HOST=$PRODUCTION_HOST_GREEN
          DEPLOY_ENV="green"
        else
          DEPLOY_HOST=$PRODUCTION_HOST_BLUE
          DEPLOY_ENV="blue"
        fi
        
        echo "Deploying to $DEPLOY_ENV environment ($DEPLOY_HOST)"
        
        # Upload to inactive environment
        scp -r ./* $PRODUCTION_USER@$DEPLOY_HOST:/opt/xpress-ops-tower/
        
        # Deploy on target server
        ssh $PRODUCTION_USER@$DEPLOY_HOST << 'EOF'
          cd /opt/xpress-ops-tower
          
          # Install dependencies
          npm ci --production
          
          # Run database migrations (if needed)
          npm run db:migrate || echo "Migration skipped"
          
          # Start performance monitoring
          node monitoring/performance-monitor.js &
          
          # Restart application
          sudo systemctl restart xpress-ops-tower
          
          # Wait for service to be ready
          sleep 60
          
          # Comprehensive health check
          for i in {1..30}; do
            if curl -f http://localhost:3000/api/health > /dev/null 2>&1; then
              echo "✅ Application health check passed"
              break
            fi
            echo "Waiting for application... ($i/30)"
            sleep 2
          done
          
          # Emergency system check
          if curl -f http://localhost:3000/api/emergency/health > /dev/null 2>&1; then
            echo "✅ Emergency system health check passed"
          else
            echo "❌ CRITICAL: Emergency system health check failed"
            exit 1
          fi
        EOF
        
        # Switch load balancer to new environment
        echo "🔄 Switching load balancer to $DEPLOY_ENV environment"
        ssh $PRODUCTION_USER@$LOAD_BALANCER_HOST << EOF
          # Update load balancer configuration
          sudo cp /opt/load-balancer/configs/$DEPLOY_ENV.conf /opt/load-balancer/active.conf
          sudo nginx -t && sudo systemctl reload nginx
          
          # Update active environment marker
          echo "$DEPLOY_ENV" > /opt/load-balancer/active-env.txt
          
          echo "✅ Load balancer switched to $DEPLOY_ENV"
        EOF
        
        echo "✅ Production deployment completed successfully"
    
    - name: Post-deployment verification
      run: |
        echo "🔍 Running post-deployment verification"
        
        # Wait for deployment to stabilize
        sleep 60
        
        # Critical system checks
        curl -f https://xpress-ops-tower.com/api/health || exit 1
        curl -f https://xpress-ops-tower.com/api/emergency/health || exit 1
        curl -f https://xpress-ops-tower.com/api/integrations/health || exit 1
        
        # Performance check
        RESPONSE_TIME=$(curl -w "%{time_total}" -o /dev/null -s https://xpress-ops-tower.com/api/health)
        if (( $(echo "$RESPONSE_TIME > 2.0" | bc -l) )); then
          echo "⚠️  High response time: ${RESPONSE_TIME}s"
        else
          echo "✅ Response time acceptable: ${RESPONSE_TIME}s"
        fi
        
        echo "✅ Post-deployment verification completed"
    
    - name: Start monitoring and alerting
      run: |
        echo "📊 Activating production monitoring"
        # Monitoring activation would go here
        echo "✅ Production monitoring active"
    
    - name: Notify deployment success
      if: success()
      run: |
        echo "🎉 Production deployment successful!"
        echo "Version: ${{ needs.build.outputs.version }}"
        echo "Commit: ${{ github.sha }}"
        echo "Deployed at: $(date -u)"

  # Rollback job (manual trigger)
  rollback:
    name: 🔄 Emergency Rollback
    runs-on: ubuntu-latest
    if: failure() && github.event.inputs.environment == 'production'
    
    steps:
    - name: Emergency rollback
      env:
        PRODUCTION_HOST_BLUE: ${{ secrets.PRODUCTION_HOST_BLUE }}
        PRODUCTION_HOST_GREEN: ${{ secrets.PRODUCTION_HOST_GREEN }}
        PRODUCTION_USER: ${{ secrets.PRODUCTION_USER }}
        PRODUCTION_SSH_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
        LOAD_BALANCER_HOST: ${{ secrets.LOAD_BALANCER_HOST }}
      run: |
        echo "🚨 Initiating emergency rollback"
        
        # Setup SSH
        mkdir -p ~/.ssh
        echo "$PRODUCTION_SSH_KEY" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H $LOAD_BALANCER_HOST >> ~/.ssh/known_hosts
        
        # Switch back to previous environment
        ssh $PRODUCTION_USER@$LOAD_BALANCER_HOST << 'EOF'
          CURRENT_ENV=$(cat /opt/load-balancer/active-env.txt)
          if [ "$CURRENT_ENV" = "blue" ]; then
            ROLLBACK_ENV="green"
          else
            ROLLBACK_ENV="blue"
          fi
          
          echo "Rolling back to $ROLLBACK_ENV environment"
          
          # Update load balancer
          sudo cp /opt/load-balancer/configs/$ROLLBACK_ENV.conf /opt/load-balancer/active.conf
          sudo nginx -t && sudo systemctl reload nginx
          echo "$ROLLBACK_ENV" > /opt/load-balancer/active-env.txt
          
          echo "✅ Emergency rollback completed"
        EOF

  # Cleanup
  cleanup:
    name: 🧹 Cleanup
    runs-on: ubuntu-latest
    needs: [deploy-production, deploy-staging]
    if: always()
    
    steps:
    - name: Cleanup old deployments
      run: |
        echo "🧹 Cleaning up old deployment artifacts"
        # Cleanup logic would go here
        echo "✅ Cleanup completed"